<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Background Test</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
        }

        .parallelogram-blue {
            position: fixed;
            height: 32px;
            background-color: lightblue;
        }

        .parallelogram-pink {
            position: fixed;
            height: 32px;
            background-color: pink;
        }
    </style>
</head>
<body>
    <script>
        const parallelogramWidthMin = 192; // 256 - 64
        const parallelogramWidthMax = 320; // 256 + 64
        const parallelogramSpacing = 64; // Minimum spacing
        const speed = 24; // px per second
        const classOptions = ['parallelogram-blue', 'parallelogram-pink']; // Two background colors
        const rowCount = Math.ceil((window.innerHeight +  heightOffsetTrig(window.innerWidth))/ 32);
        const maxPerRow = 1; // Max parallelograms per row

        function heightOffsetTrig(x) {
            let angle = 32 * (Math.PI/180);
            let y = x * Math.tan(angle);
            return y;
        }

        // Function to generate parallelograms
        function generateParallelogram(rowIndex) {
            const div = document.createElement('div');
            div.classList.add(classOptions[Math.floor(Math.random() * classOptions.length)]);

            // Randomly assign width
            const width = Math.floor(Math.random() * (parallelogramWidthMax - parallelogramWidthMin + 1)) + parallelogramWidthMin;
            div.style.width = width + 'px';

            // Set position, starting just off the right side of the screen
            const startLeft = Math.floor(Math.random() * (window.innerWidth - width));
            div.style.transform = 'skew(64deg) rotate(32deg) translateX(' + startLeft + 'px)';
            div.style.top = (rowIndex * 32) - heightOffsetTrig(window.innerWidth) + 'px';

            // Add the div as the first child
            document.body.insertBefore(div, document.body.firstChild);

            // Initialize animation
            animateParallelogram(div, startLeft);
        }

        function parseXPos(div) {
            const transform = div.style.transform;
            const translateXMatch = transform.match(/translateX\((-?\d+\.?\d*)px\)/);
            return translateXMatch ? parseFloat(translateXMatch[1]) : 0;
        }

        // Function to animate a parallelogram
        function animateParallelogram(div, startX) {
            let lastTime = null;
            const moveParallelogram = (currentTime) => {
                const leftPos = parseXPos(div);
                if (leftPos > window.innerWidth - (parseFloat(div.style.width)/2)) {
                    // Reset when moving off-screen
                    div.style.transform = `skew(64deg) rotate(32deg) translateX(${ - (parseFloat(div.style.width)/2) }px)`;
                } else {
                    // Move according to the speed and rotation
                    let deltaTime = (currentTime - lastTime) / 1000;
                    div.style.transform = `skew(64deg) rotate(32deg) translateX(${leftPos + (speed * deltaTime)}px)`;
                    lastTime = currentTime;
                }
                requestAnimationFrame(moveParallelogram);
            };
            requestAnimationFrame(moveParallelogram);
        }

        // Generate parallelograms row by row, and multiple per row
        function generateParallelograms() {
            for (let i = 0; i < rowCount; i++) {
                let count = Math.min(Math.floor(Math.random() * maxPerRow) + 1, maxPerRow); // Random number of parallelograms per row
                let lastX = 0;
                for (let j = 0; j < count; j++) {
                    const width = Math.floor(Math.random() * (parallelogramWidthMax - parallelogramWidthMin + 1)) + parallelogramWidthMin;
                    const xPos = lastX + width + Math.floor(Math.random() * (parallelogramWidthMax - parallelogramWidthMin + 1)) + parallelogramSpacing;
                    lastX = xPos;
                    if (xPos > window.innerWidth + 340) break; // Ensure no overlaps outside the screen width
                    generateParallelogram(i); 
                }
            }
        }

        // Mutation observer to detect new parallelograms
        const observer = new MutationObserver((mutationsList) => {
            for (const mutation of mutationsList) {
                if (mutation.addedNodes.length) {
                    mutation.addedNodes.forEach((node) => {
                        if (node.classList && node.classList.contains('parallelogram-blue') || node.classList && node.classList.contains('parallelogram-pink') ) {
                            const leftPos = parseFloat(node.style.left);
                            animateParallelogram(node, leftPos);
                        }
                    });
                }
            }
        });

        // Observe mutations to the body
        observer.observe(document.body, { childList: true });

        // Start generating parallelograms
        generateParallelograms();
    </script>
</body>
