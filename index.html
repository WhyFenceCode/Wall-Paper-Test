<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parallelogram Generator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
        }

        .parallelogram {
            position: fixed;
            height: 32px;
            transform: skew(64deg) rotate(32deg);
            background-color: lightblue;
            will-change: transform;
        }
    </style>
</head>
<body>
    <script>
        const parallelogramWidthMin = 192; // 256 - 64
        const parallelogramWidthMax = 320; // 256 + 64
        const parallelogramSpacing = 64; // Minimum spacing between parallelograms horizontally
        const speed = 24; // px per second horizontal speed
        const angleInRadians = 32 * Math.PI / 180; // Convert degrees to radians for trigonometric calculations
        const verticalSpeed = speed * Math.tan(angleInRadians); // The vertical speed based on the 32deg movement
        const colorOptions = ['#3498db', '#2ecc71']; // Two background colors
        const rowCount = Math.floor(window.innerHeight / 32); // Number of rows to fill vertically
        const maxPerRow = 5; // Max parallelograms per row

        // Function to generate parallelograms
        function generateParallelogram(rowIndex, xPos) {
            const div = document.createElement('div');
            div.classList.add('parallelogram');

            // Randomly assign width
            const width = Math.floor(Math.random() * (parallelogramWidthMax - parallelogramWidthMin + 1)) + parallelogramWidthMin;
            div.style.width = width + 'px';

            // Randomly assign starting color
            div.style.backgroundColor = colorOptions[Math.floor(Math.random() * colorOptions.length)];

            // Set position, starting just off the right side of the screen
            div.style.left = `${xPos}px`;
            div.style.top = `${rowIndex * 32}px`;

            // Add the div as the first child
            document.body.insertBefore(div, document.body.firstChild);

            // Initialize animation
            animateParallelogram(div, xPos);
        }

        // Function to animate a parallelogram
        function animateParallelogram(div, startX) {
            let lastTimestamp = 0;
            const moveParallelogram = (timestamp) => {
                if (!lastTimestamp) lastTimestamp = timestamp;
                const elapsed = timestamp - lastTimestamp;

                const leftPos = parseFloat(div.style.left);
                const topPos = parseFloat(div.style.top);

                if (leftPos > window.innerWidth) {
                    // Reset when moving off-screen
                    div.style.left = '-64px'; // Start just off the left side of the screen
                    div.style.top = `${(topPos - verticalSpeed * elapsed / 1000) % window.innerHeight}px`; // Continue vertical movement
                } else {
                    // Move according to the speed and angle of movement (32 degrees)
                    div.style.left = leftPos + (speed * elapsed / 1000) + 'px';
                    div.style.top = topPos + (verticalSpeed * elapsed / 1000) + 'px';
                }

                lastTimestamp = timestamp;
                requestAnimationFrame(moveParallelogram);
            };
            requestAnimationFrame(moveParallelogram);
        }

        // Generate parallelograms row by row, and multiple per row
        function generateParallelograms() {
            for (let i = 0; i < rowCount; i++) {
                let lastX = 0;
                let count = Math.min(Math.floor(Math.random() * maxPerRow) + 1, maxPerRow); // Random number of parallelograms per row

                for (let j = 0; j < count; j++) {
                    const width = Math.floor(Math.random() * (parallelogramWidthMax - parallelogramWidthMin + 1)) + parallelogramWidthMin;
                    const xPos = lastX + Math.floor(Math.random() * (parallelogramWidthMax - parallelogramWidthMin + 1)) + parallelogramSpacing;
                    if (xPos > window.innerWidth - width) break; // Ensure no overlaps outside the screen width

                    lastX = xPos + width + parallelogramSpacing;
                    generateParallelogram(i, xPos);
                }
            }
        }

        // Mutation observer to detect new parallelograms
        const observer = new MutationObserver((mutationsList) => {
            for (const mutation of mutationsList) {
                if (mutation.addedNodes.length) {
                    mutation.addedNodes.forEach((node) => {
                        if (node.classList && node.classList.contains('parallelogram')) {
                            const leftPos = parseFloat(node.style.left);
                            animateParallelogram(node, leftPos);
                        }
                    });
                }
            }
        });

        // Observe mutations to the body
        observer.observe(document.body, { childList: true });

        // Start generating parallelograms
        generateParallelograms();
    </script>
</body>
</html>
