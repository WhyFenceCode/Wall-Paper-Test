<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Background Test</title>
    <style>
        @font-face {
          font-family: 'Blanka';
          src: url('./fonts/blanka/Blanka.otf') format('opentype');
          font-weight: normal;
          font-style: normal;
        }

        :root {
            --clr-pink: hsl(317 100% 54% / .7);
            --clr-pink-neon: hsl(317 100% 54%);
            --clr-blue: hsl(197 100% 54% / .7);
            --clr-blue-neon: hsl(197 100% 54%);
        }
        
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
        }

        .parallelogram-blue {
            position: fixed;
            transform-origin: top left;
            border-radius: 4px;
            left: 0;
            top: 0;
            height: 32px;
            background-color: var(--clr-blue);
            box-shadow: 
                0 0 0 10px var(--clr-blue-neon),
                0 0 0 20px var(--clr-blue-neon),
                0 0 0 40px var(--clr-blue-neon),
                0 0 0 80px var(--clr-blue-neon),
                0 0 0 160px var(--clr-blue-neon);
        }

        .parallelogram-pink {
            position: fixed;
            transform-origin: top left;
            border-radius: 4px;
            left: 0;
            top: 0;
            height: 32px;
            background-color: var(--clr-pink);
            box-shadow: 
                0 0 0 10px var(--clr-pink-neon),
                0 0 0 20px var(--clr-pink-neon),
                0 0 0 40px var(--clr-pink-neon),
                0 0 0 80px var(--clr-pink-neon),
                0 0 0 160px var(--clr-pink-neon);
        }

        .text {
          font-family: "Blanka";
          font-size: 5em;
          letter-spacing: 0.2em;
          color: rgba(192, 192, 192, 1);
          position: fixed;
          top: 50%;
          left: 50%;
          transform-origin: center;
          transform: translate(-50%, -110%);
          text-shadow: 2px 3px 7px rgba(0, 0, 0, 0.45);
        }
    </style>
</head>
<body>
    <h1 class="text" id="date">%DATE_FETCH_ERROR%</h1>
    <script>
        //Date Constants
        const months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        const textObject =   document.getElementById('date');

        //Animation Constants
        const parallelogramWidthMin = 192; // 256 - 64
        const parallelogramWidthMax = 320; // 256 + 64
        const parallelogramSpacing = 24; // Minimum spacing
        const respawnOffset = 20;
        const rowSeperation = 48;
        const speed = 24; // px per second
        const classOptions = ['parallelogram-blue', 'parallelogram-pink']; // Two background colors
        const rowCount = Math.ceil((window.innerHeight +  heightOffsetTrig(window.innerWidth))/ rowSeperation);
        const maxPerRow = 2; // Max parallelograms per row

        function heightOffsetTrig(x) {
            let angle = 32 * (Math.PI/180);
            let y = x * Math.tan(angle);
            return y;
        }

        function doRangesOverlap(a1, a2, b1, b2) {
            let aw = Math.abs(a1 - a2);
            let bw = Math.abs(b1 - b2);
            let ac = Math.min(a1, a2) + (aw/2);
            let bc = Math.min(b1, b2) + (bw/2);

            let distAB = Math.abs(ac-bc);

            return distAB >= (aw/2) + (bw/2) + parallelogramSpacing;
        }

        // Function to generate parallelograms
        function generateParallelogram(rowIndex, w, l, lw) {
            const div = document.createElement('div');
            div.classList.add(classOptions[Math.floor(Math.random() * classOptions.length)]);

            // Randomly assign width
            div.style.width = w + 'px';

            // Set position, starting just off the right side of the screen
            let startLeft = Math.floor((Math.random() * (window.innerWidth + w)) - w);
            if (l == 0){
                div.style.transform = 'skew(64deg) rotate(32deg) translateX(' + startLeft + 'px)';
            } else {
                let k = 0;
                //while (doRangesOverlap(l, l+lw, startLeft, startLeft+w) && k < 50) {
                while (!doRangesOverlap(l, l+lw, startLeft, startLeft+w)) {
                    startLeft = Math.floor((Math.random() * (window.innerWidth + w)) - w);
                    k++;
                }
                console.log(k);
                div.style.transform = 'skew(64deg) rotate(32deg) translateX(' + startLeft + 'px)';
            }
            div.style.top = (rowIndex * rowSeperation) - heightOffsetTrig(window.innerWidth) + 'px';

            // Add the div as the first child
            document.body.insertBefore(div, document.body.firstChild);

            // Initialize animation
            animateParallelogram(div, startLeft, w);
        }

        function parseXPos(div) {
            const transform = div.style.transform;
            const translateXMatch = transform.match(/translateX\((-?\d+\.?\d*)px\)/);
            return translateXMatch ? parseFloat(translateXMatch[1]) : 0;
        }

        // Function to animate a parallelogram
        function animateParallelogram(div, startX, w) {
            let lastTime = null;
            const moveParallelogram = (currentTime) => {
                const leftPos = parseXPos(div);
                if (leftPos > (window.innerWidth-w)) {
                    // Reset when moving off-screen
                    div.style.transform = `skew(64deg) rotate(32deg) translateX(${-w-respawnOffset}px)`;
                } else {
                    // Move according to the speed and rotation
                    let deltaTime = (currentTime - lastTime) / 1000;
                    div.style.transform = `skew(64deg) rotate(32deg) translateX(${leftPos + (speed * deltaTime)}px)`;
                    lastTime = currentTime;
                }
                requestAnimationFrame(moveParallelogram);
            };
            requestAnimationFrame(moveParallelogram);
        }

        // Generate parallelograms row by row, and multiple per row
        function generateParallelograms() {
            for (let i = 0; i < rowCount; i++) {
                let count = Math.min(Math.floor(Math.random() * maxPerRow) + 1, maxPerRow); // Random number of parallelograms per row
                let lastX = 0;
                let lastW = 0;
                for (let j = 0; j < count; j++) {
                    const width = Math.floor(Math.random() * (parallelogramWidthMax - parallelogramWidthMin + 1)) + parallelogramWidthMin;
                    const xPos = lastX + width + Math.floor(Math.random() * (parallelogramWidthMax - parallelogramWidthMin + 1)) + parallelogramSpacing;
                    const xOffest = width + Math.floor(Math.random() * (parallelogramWidthMax - parallelogramWidthMin + 1)) + parallelogramSpacing;
                    if (xPos > window.innerWidth + 340) break; // Ensure no overlaps outside the screen width
                    generateParallelogram(i, width, lastX, lastW);
                    lastX = xPos;
                    lastW = width;
                }
            }
        }

        // Mutation observer to detect new parallelograms
        const observer = new MutationObserver((mutationsList) => {
            for (const mutation of mutationsList) {
                if (mutation.addedNodes.length) {
                    mutation.addedNodes.forEach((node) => {
                        if (node.classList && node.classList.contains('parallelogram-blue') || node.classList && node.classList.contains('parallelogram-pink') ) {
                            const leftPos = parseFloat(node.style.left);
                            animateParallelogram(node, leftPos);
                        }
                    });
                }
            }
        });

        // Observe mutations to the body
        observer.observe(document.body, { childList: true });

        // Start generating parallelograms
        generateParallelograms();

        //Do the Date
        function setDateText(){
          let d = new Date();
          let data = months[d.getMonth()];
          data = data + " " + d.getDate();
          textObject.innerHTML = data;
        }
        
        setDateText();
        setInterval(setDateText, 500);
    </script>
</body>
