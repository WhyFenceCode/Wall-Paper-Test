<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Background Test</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
        }

        .parallelogram-blue {
            position: fixed;
            height: 32px;
            background-color: lightblue;
        }

        .parallelogram-pink {
            position: fixed;
            height: 32px;
            background-color: pink;
        }
    </style>
</head>
<body>
    <script>
        const parallelogramWidthMin = 192; // 256 - 64
        const parallelogramWidthMax = 320; // 256 + 64
        const parallelogramSpacing = 24; // Minimum spacing
        const rowSeperation = 48;
        const speed = 24; // px per second
        const classOptions = ['parallelogram-blue', 'parallelogram-pink']; // Two background colors
        const rowCount = Math.ceil((window.innerHeight +  heightOffsetTrig(window.innerWidth))/ rowSeperation);
        const maxPerRow = 2; // Max parallelograms per row

        function heightOffsetTrig(x) {
            let angle = 32 * (Math.PI/180);
            let y = x * Math.tan(angle);
            return y;
        }

        function doRangesOverlap(a1, a2, b1, b2) {
            let aw = Math.abs(a1 - a2);
            let bw = Math.abs(b1 - b2);
            let ac = Math.min(a1, a2) + (aw/2);
            let bc = Math.min(b1, b2) + (bw/2);

            let distAB = Math.abs(ac-bc);

            return distAB <= (aw/2) + (bw/2) + parallelogramSpacing;
        }

        // Function to generate parallelograms
        function generateParallelogram(rowIndex, w, l, lw) {
            const div = document.createElement('div');
            div.classList.add(classOptions[Math.floor(Math.random() * classOptions.length)]);

            // Randomly assign width
            div.style.width = w + 'px';

            // Set position, starting just off the right side of the screen
            let startLeft = Math.floor((Math.random() * (window.innerWidth + w)) - w);
            if (l == 0){
                div.style.transform = 'skew(64deg) rotate(32deg) translateX(' + startLeft + 'px)';
            } else {
                let k = 0;
                while (doRangesOverlap(l, l+lw, startLeft, startLeft+w) && k < 50) {
                    startLeft = Math.floor((Math.random() * (window.innerWidth + w)) - w);
                    k++;
                }
                console.log(k);
                div.style.transform = 'skew(64deg) rotate(32deg) translateX(' + startLeft + 'px)';
            }
            div.style.top = (rowIndex * rowSeperation) - heightOffsetTrig(window.innerWidth) + 'px';

            // Add the div as the first child
            document.body.insertBefore(div, document.body.firstChild);

            // Initialize animation
            animateParallelogram(div, startLeft, w);
        }

        function parseXPos(div) {
            const transform = div.style.transform;
            const translateXMatch = transform.match(/translateX\((-?\d+\.?\d*)px\)/);
            return translateXMatch ? parseFloat(translateXMatch[1]) : 0;
        }

        // Function to animate a parallelogram
        function animateParallelogram(div, startX, w) {
            let lastTime = null;
            const moveParallelogram = (currentTime) => {
                const leftPos = parseXPos(div);
                if (leftPos > (window.innerWidth-w)) {
                    // Reset when moving off-screen
                    div.style.transform = `skew(64deg) rotate(32deg) translateX(${-w}px)`;
                } else {
                    // Move according to the speed and rotation
                    let deltaTime = (currentTime - lastTime) / 1000;
                    div.style.transform = `skew(64deg) rotate(32deg) translateX(${leftPos + (speed * deltaTime)}px)`;
                    lastTime = currentTime;
                }
                requestAnimationFrame(moveParallelogram);
            };
            requestAnimationFrame(moveParallelogram);
        }

        // Generate parallelograms row by row, and multiple per row
        function generateParallelograms() {
            for (let i = 0; i < rowCount; i++) {
                let count = Math.min(Math.floor(Math.random() * maxPerRow) + 1, maxPerRow); // Random number of parallelograms per row
                let lastX = 0;
                let lastW = 0;
                for (let j = 0; j < count; j++) {
                    const width = Math.floor(Math.random() * (parallelogramWidthMax - parallelogramWidthMin + 1)) + parallelogramWidthMin;
                    const xPos = lastX + width + Math.floor(Math.random() * (parallelogramWidthMax - parallelogramWidthMin + 1)) + parallelogramSpacing;
                    const xOffest = width + Math.floor(Math.random() * (parallelogramWidthMax - parallelogramWidthMin + 1)) + parallelogramSpacing;
                    if (xPos > window.innerWidth + 340) break; // Ensure no overlaps outside the screen width
                    generateParallelogram(i, width, lastX, lastW);
                    lastX = xPos;
                    lastW = width;
                }
            }
        }

        // Mutation observer to detect new parallelograms
        const observer = new MutationObserver((mutationsList) => {
            for (const mutation of mutationsList) {
                if (mutation.addedNodes.length) {
                    mutation.addedNodes.forEach((node) => {
                        if (node.classList && node.classList.contains('parallelogram-blue') || node.classList && node.classList.contains('parallelogram-pink') ) {
                            const leftPos = parseFloat(node.style.left);
                            animateParallelogram(node, leftPos);
                        }
                    });
                }
            }
        });

        // Observe mutations to the body
        observer.observe(document.body, { childList: true });

        // Start generating parallelograms
        generateParallelograms();
    </script>
</body>
